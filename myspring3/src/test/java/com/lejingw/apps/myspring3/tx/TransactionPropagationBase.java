package com.lejingw.apps.myspring3.tx;

import junit.framework.Assert;

import org.springframework.context.ApplicationContext;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.IllegalTransactionStateException;

import com.lejingw.apps.myspring3.tx.model.AddressModel;
import com.lejingw.apps.myspring3.tx.model.UserModel;
import com.lejingw.apps.myspring3.tx.service.IAddressService;
import com.lejingw.apps.myspring3.tx.service.IUserService;

public class TransactionPropagationBase {

	protected static final String CREATE_USER_TABLE_SQL = "create table user"
			+ "(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
			+ "name varchar(100))";
	protected static final String DROP_USER_TABLE_SQL = "drop table user";

	protected static final String CREATE_ADDRESS_TABLE_SQL = "create table address"
			+ "(id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY, "
			+ "province varchar(100), city varchar(100), street varchar(100), user_id int)";
	protected static final String DROP_ADDRESS_TABLE_SQL = "drop table address";
	
	protected void requiredWithSuccess(ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean("requiredUserServiceWithSuccess", IUserService.class);
		IAddressService addressService = ctx2.getBean("requiredAddressServiceWithSuccess", IAddressService.class);
		userService.save(user);
		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());
	}

	protected void requiredWithRuntimeException(ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean("requiredUserServiceWithRuntimeException", IUserService.class);
		IAddressService addressService = ctx2.getBean("requiredAddressServiceWithRuntimeException", IAddressService.class);
		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}
		// 因为发生回滚，所以countAll都是0
		Assert.assertEquals(0, userService.countAll());
		Assert.assertEquals(0, addressService.countAll());
	}

	protected void requiresNewWithSuccess(ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean("requiresNewUserServiceWithSuccess", IUserService.class);
		IAddressService addressService = ctx2.getBean("requiresNewAddressServiceWithSuccess", IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());
	}

	protected void requiresNewWithRuntimeException(ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean("requiresNewUserServiceWithRuntimeException", IUserService.class);
		IAddressService addressService = ctx2.getBean("requiresNewAddressServiceWithRuntimeException", IAddressService.class);
		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}

		// 因为userService中抛出异常，而addressService成功执行，所以有如下结果
		Assert.assertEquals(0, userService.countAll());// 事务失败了
		Assert.assertEquals(1, addressService.countAll());// 事务成功执行了

	}

	protected void requiredAndSupportsWithSuccess(ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2
				.getBean("requiredAndSupportsUserServiceWithSuccess",
						IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndSupportsAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());

	}

	protected void requiredAndSupportsWithRuntimeException(
			ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndSupportsUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndSupportsAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
			e.printStackTrace();
		}

		// 因为发生回滚，所以countAll都是0
		Assert.assertEquals(0, userService.countAll());
		Assert.assertEquals(0, addressService.countAll());
	}

	protected void supportsAndSupportsWithSuccess(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2
				.getBean("supportsAndSupportsUserServiceWithSuccess",
						IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"supportsAndSupportsAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());

	}

	protected void supportsAndSupportsWithRuntimeException(
			ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean(
				"supportsAndSupportsUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"supportsAndSupportsAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}

		// 即使发生回滚，由于运行在非事务环境，所以countAll都是1，类似于JDBC无事务环境
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());
	}

	protected void requiredAndNotSupportedWithSuccess(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndNotSupportedUserServiceWithSuccess",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndNotSupportedAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());

	}

	protected void requiredAndNotSupportedWithRuntimeException(
			ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndNotSupportedUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndNotSupportedAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}

		// 由于addressService.save方法允许在非事务环境，因此addressService.countAll()为1
		// 而userService的save方法允许在事务环境，且遭遇addressService.save方法抛出的异常，
		// 因此需要回滚，所以userService.countAll()为0

		Assert.assertEquals(0, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());
	}

	protected void supportsAndNotSupportedWithSuccess(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"supportsAndNotSupportedUserServiceWithSuccess",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"supportsAndNotSupportedAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());

	}

	protected void supportsAndNotSupportedWithRuntimeException(
			ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean(
				"supportsAndNotSupportedUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"supportsAndNotSupportedAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}

		// 即使发生回滚，由于运行在非事务环境，所以countAll都是1，类似于JDBC无事务环境
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());
	}

	protected void requiredAndMandatoryWithSuccess(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndMandatoryUserServiceWithSuccess",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndMandatoryAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());

	}

	protected void requiredAndMandatoryWithRuntimeException(
			ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndMandatoryUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndMandatoryAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}

		// 回滚事务，由于userService.save()和addressService.save()运行在同一事务，所以userService.countAll()为0
		Assert.assertEquals(0, userService.countAll());
		Assert.assertEquals(0, addressService.countAll());
	}

	protected void supportsAndMandatoryWithRuntimeException(
			ApplicationContext ctx2, UserModel user) {
		IUserService userService = ctx2.getBean(
				"supportsAndMandatoryUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"supportsAndMandatoryAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
			Assert.assertTrue(e instanceof IllegalTransactionStateException);
		}

		// 由于userService.save()方法运行在Supports传播行为中，即无事务支持，因此userService.countAll()将返回1
		// 由于addressService必须允许在事务环境，但当前没有事务所以将抛出异常，因此addressService.countAll()返回0
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(0, addressService.countAll());
	}

	protected void requiredAndNeverWithRuntimeException(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndNeverUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndNeverAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
			Assert.assertTrue(e instanceof IllegalTransactionStateException);
		}

		// 回滚事务
		Assert.assertEquals(0, userService.countAll());
		Assert.assertEquals(0, addressService.countAll());
	}

	protected void supportsAndNeverWithSuccess(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"supportsAndNeverUserServiceWithSuccess", IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"supportsAndNeverAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());
	}

	protected void supportsAndNeverWithRuntimeException(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"supportsAndNeverUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"supportsAndNeverAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}

		// 由于userService.save()方法运行在Supports传播行为中，即无事务支持，即使抛出异常，也不影响前面的操作，因此userService.countAll()将返回1
		// 由于addressService.save()方法运行在Never传播行为中,即不支持事务，即使抛出异常，也不影响前面的操作，因此addressService.countAll()返回1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());
	}

	protected void requiredAndNestedWithSuccess(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndNestedUserServiceWithSuccess", IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndNestedAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());

	}

	protected void requiredAndNestedWithRuntimeException(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"requiredAndNestedUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"requiredAndNestedAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
//			Assert.fail();
		} catch (Exception e) {
			e.printStackTrace();
		}

		// 由于addressService.save()方法事务内抛出异常，因此将回滚该嵌套事务内的操作
		// userService.save()方法捕获了addressService.save()抛出的异常，
		// 虽然嵌套事务回滚了，但由于捕获了异常，因此对嵌套事务对外部事务无影响
		// 类似于RequiresNew，但嵌套事务属于同一个物理事务，采用JDBC保存点实现回滚到指定保存点
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(0, addressService.countAll());
	}

	protected void nestedAndNestedWithSuccess(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"nestedAndNestedUserServiceWithSuccess", IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"nestedAndNestedAddressServiceWithSuccess",
				IAddressService.class);

		userService.save(user);

		// 正确执行，所以countAll都是1
		Assert.assertEquals(1, userService.countAll());
		Assert.assertEquals(1, addressService.countAll());

	}

	protected void nestedAndNestedWithRuntimeException(ApplicationContext ctx2,
			UserModel user) {
		IUserService userService = ctx2.getBean(
				"nestedAndNestedUserServiceWithRuntimeException",
				IUserService.class);
		IAddressService addressService = ctx2.getBean(
				"nestedAndNestedAddressServiceWithRuntimeException",
				IAddressService.class);

		try {
			userService.save(user);
			Assert.fail();
		} catch (RuntimeException e) {
		}

		// 外部事务回滚将导致内部事务也回滚
		Assert.assertEquals(0, userService.countAll());
		Assert.assertEquals(0, addressService.countAll());
	}

	protected static UserModel createDefaultUserModel() {
		UserModel user = new UserModel();
		user.setName("test");
		AddressModel address = new AddressModel();
		address.setProvince("beijing");
		address.setCity("beijing");
		address.setStreet("haidian");
		user.setAddress(address);
		return user;
	}

	protected void prepareTable(JdbcTemplate jdbcTemplate2) {
		jdbcTemplate2.update(CREATE_USER_TABLE_SQL);
		jdbcTemplate2.update(CREATE_ADDRESS_TABLE_SQL);
	}

	protected void cleanTable(JdbcTemplate jdbcTemplate2) {
		jdbcTemplate2.update(DROP_USER_TABLE_SQL);
		jdbcTemplate2.update(DROP_ADDRESS_TABLE_SQL);
	}
}
